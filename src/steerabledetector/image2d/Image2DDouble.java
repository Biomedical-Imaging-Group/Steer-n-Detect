//====================================================================================================// Project: Steer'n'Detect// // Authors: Zsuzsanna Puspoki and Daniel Sage// Organization: Biomedical Imaging Group (BIG), Ecole Polytechnique Federale de Lausanne// Address: EPFL-STI-IMT-LIB, 1015 Lausanne, Switzerland//// Information: http://bigwww.epfl.ch/algorithms/steer_n_detect///// Reference:// Zsuzsanna Puspoki et al. submitted to Bioinformatics 2019//// Conditions of use:// You'll be free to use this software for research purposes, but you should not redistribute // it without our consent. In addition, we expect you to include a citation whenever you // present or publish results that are based on it.//====================================================================================================package steerabledetector.image2d;import ij.ImagePlus;import ij.ImageStack;import ij.process.ByteProcessor;import ij.process.ColorProcessor;import ij.process.FloatProcessor;import ij.process.ImageProcessor;import ij.process.ShortProcessor;public class Image2DDouble {	private double[]	data	= null;	private int			nx		= 0;	private int			ny		= 0;	private int			nxy		= 0;	public Image2DDouble(int nx, int ny) {		this.nx = nx;		this.ny = ny;		allocate();	}	public Image2DDouble(double data[], int nx, int ny) {		this.nx = nx;		this.ny = ny;		this.nxy = nx * ny;		this.data = data;	}	public Image2DDouble(ImagePlus imp) {		this.nx = imp.getWidth();		this.ny = imp.getHeight();		this.nxy = nx * ny;		allocate();		ImageProcessor ip = imp.getProcessor();		if (ip instanceof ByteProcessor) {			ByteProcessor bp = (ByteProcessor)ip;			byte[] pix = (byte[])bp.getPixels();			for (int k = 0; k < nxy; k++)				data[k] = (double) (pix[k] & 0xFF);		}		else if (ip instanceof ShortProcessor) {			ShortProcessor bp = (ShortProcessor)ip;			short[] pix = (short[])bp.getPixels();			for (int k = 0; k < nxy; k++)				data[k] = (double) (pix[k] & 0xFFFF);		}		else if (ip instanceof FloatProcessor) {			FloatProcessor bp = (FloatProcessor)ip;			float[] pix = (float[])bp.getPixels();			for (int k = 0; k < nxy; k++)				data[k] = (double) pix[k];		}		else if (ip instanceof ColorProcessor) {			double r, g, b;			int c;			ColorProcessor cp;			int[] pixels;			cp = (ColorProcessor) imp.getProcessor();			pixels = (int[]) cp.getPixels();			for (int k = 0; k < nxy; k++) {				c = pixels[k];				r = (double) ((c & 0xFF0000) >> 16);				g = (double) ((c & 0xFF00) >> 8);				b = (double) ((c & 0xFF));				data[k] = (double) ((r + g + b) / 3.0);			}		}	}	public Image2DDouble(double[][] array) {		this.nx = array.length;		this.ny = array[0].length;		allocate();		putXY(0, 0, array);	}	public int getWidth() {		return nx;	}	public int getHeight() {		return ny;	}	public void putX(int x, int y, double[] buffer) {		int offset = x + y * nx;		int leni = buffer.length;		System.arraycopy(buffer, 0, data, offset, leni);	}	public void putY(int x, int y, double[] buffer) {		int offset = x + y * nx;		int leni = buffer.length;		for (int i = 0; i < leni; i++) {			data[offset] = buffer[i];			offset += nx;		}	}	public void putXY(int x, int y, double[][] buffer) {		int offset = x + y * nx;		int leni = buffer.length;		int lenj = buffer[0].length;		for (int j = 0; j < lenj; j++) {			offset = x + (y + j) * nx;			for (int i = 0; i < leni; i++, offset++) {				data[offset] = buffer[i][j];			}		}	}	public void getX(int x, int y, double[] buffer) {		int offset = x + y * nx;		int leni = buffer.length;		System.arraycopy(data, offset, buffer, 0, leni);	}	public void getY(int x, int y, double[] buffer) {		int offset = x + y * nx;		int leni = buffer.length;		for (int i = 0; i < leni; i++) {			buffer[i] = data[offset];			offset += nx;		}	}	public void getXY(int x, int y, double[][] buffer) {		int offset = x + y * nx;		int leni = buffer.length;		int lenj = buffer[0].length;		for (int j = 0; j < lenj; j++) {			offset = x + (y + j) * nx;			for (int i = 0; i < leni; i++, offset++) {				buffer[i][j] = data[offset];			}		}	}	public double[] getData() {		return data;	}	private void allocate() {		this.nxy = nx * ny;		this.data = new double[nxy];	}	public Image2DDouble duplicate() {		Image2DDouble out = new Image2DDouble(nx, ny);		double[] outdata = out.getData();		System.arraycopy(data, 0, outdata, 0, nxy);		out.putX(0, 0, outdata);		return out;	}	public double getMinimum() {		double min = Double.MAX_VALUE;		double[] slice = (data);		for (int k = 0; k < nxy; k++)			if ((slice[k]) < min)				min = slice[k];		return min;	}	public double getMaximum() {		double max = -Double.MAX_VALUE;		double[] slice = (data);		for (int k = 0; k < nxy; k++)			if ((slice[k]) > max)				max = slice[k];		return max;	}	public double getMean() {		return getTotal() / (nxy);	}	private double getTotal() {		double total = 0.0;		double[] slice = (data);		for (int k = 0; k < nxy; k++)			total += slice[k];		return total;	}	public ImageStack buildImageStack() {		ImageStack imagestack = new ImageStack(nx, ny);		FloatProcessor ip = new FloatProcessor(nx, ny);		float pix[] = (float[]) ip.getPixels();		for (int k = 0; k < nxy; k++)			pix[k] = (float) (data[k]);		imagestack.addSlice("", ip);		return imagestack;	}	public void abs() {		for (int k = 0; k < nxy; k++)			if (data[k] < 0.0)				data[k] = -data[k];	}	public void log() {		for (int k = 0; k < nxy; k++)			data[k] = Math.log(data[k]);	}	public void exp() {		for (int k = 0; k < nxy; k++)			data[k] = Math.exp(data[k]);	}	public void sqrt() {		for (int k = 0; k < nxy; k++)			data[k] = Math.sqrt(data[k]);	}	public void sqr() {		for (int k = 0; k < nxy; k++)			data[k] *= data[k];	}	public void add(double constant) {		for (int k = 0; k < nxy; k++)			data[k] += constant;	}	public void multiply(double constant) {		for (int k = 0; k < nxy; k++)			data[k] *= constant;	}	public void max(Image2DDouble image2d) {		double[] tmp = image2d.getData();		for (int k = 0; k < nxy; k++) {			if (data[k] < tmp[k])				data[k] = tmp[k];		}	}	public void min(Image2DDouble image2d) {		double[] tmp = image2d.getData();		for (int k = 0; k < nxy; k++) {			if (data[k] > tmp[k])				data[k] = tmp[k];		}	}	public void add(Image2DDouble image2d) {		double[] tmp = image2d.getData();		for (int k = 0; k < nxy; k++)			data[k] += tmp[k];	}	public void multiply(Image2DDouble image2d) {		double[] tmp = image2d.getData();		for (int k = 0; k < nxy; k++)			data[k] *= tmp[k];	}	public void subtract(Image2DDouble image2d) {		double[] tmp = image2d.getData();		for (int k = 0; k < nxy; k++)			data[k] -= tmp[k];	}	public void divide(Image2DDouble image2d) {		double[] tmp = image2d.getData();		for (int k = 0; k < nxy; k++)			data[k] /= tmp[k];	}	public double getPixel(int x, int y) {		if (x < 0)			return 0;		if (y < 0)			return 0;		if (x >= nx)			return 0;		if (y >= ny)			return 0;		return data[x + y * nx];	}	public void putPixel(int x, int y, double value) {		if (x < 0)			return;		if (y < 0)			return;		if (x >= nx)			return;		if (y >= ny)			return;		data[x + y * nx] = (double) value;	}	public double getInterpolatedPixel(double x, double y) {		if (x > nx - 1)			return 0.0;		if (y > ny - 1)			return 0.0;		if (x < 0)			return 0.0;		if (y < 0)			return 0.0;				int i = (x >= 0.0 ? ((int) x) : ((int) x - 1));		int j = (y >= 0.0 ? ((int) y) : ((int) y - 1));		boolean fi = (i == nx - 1);		boolean fj = (j == ny - 1);		int index = i + j * nx;					double v2_00 = (double) ((data)[index]);		double v2_10 = (fi ? v2_00 : data[index + 1]);		double v2_01 = (fj ? v2_00 : data[index + nx]);		double v2_11 = (fi ? (fj ? v2_00 : v2_01) : data[index + 1 + nx]);		double dx2 = x - (double) i;		double dy2 = y - (double) j;		return (dx2 * (v2_11 * dy2 - v2_10 * (dy2 - 1.0)) - (dx2 - 1.0) * (v2_01 * dy2 - v2_00 * (dy2 - 1.0)));	}}